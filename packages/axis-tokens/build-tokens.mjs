import StyleDictionary from 'style-dictionary';
import { writeFileSync, mkdirSync } from 'fs';
import { dirname } from 'path';

// --- HEX → HSL 변환 유틸 ---
function hexToHsl(hex) {
  hex = hex.replace('#', '');
  const r = parseInt(hex.substring(0, 2), 16) / 255;
  const g = parseInt(hex.substring(2, 4), 16) / 255;
  const b = parseInt(hex.substring(4, 6), 16) / 255;

  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h, s, l = (max + min) / 2;

  if (max === min) {
    h = s = 0;
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
      case g: h = ((b - r) / d + 2) / 6; break;
      case b: h = ((r - g) / d + 4) / 6; break;
    }
  }

  return `${Math.round(h * 360)} ${Math.round(s * 100)}% ${Math.round(l * 100)}%`;
}

// --- 커스텀 포맷: CSS Variables ---
StyleDictionary.registerFormat({
  name: 'css/axis-variables',
  format: async ({ dictionary }) => {
    const tokens = dictionary.allTokens
      .map(token => `  --axis-${token.path.join('-')}: ${token.value};`)
      .join('\n');

    return `:root {\n${tokens}\n}\n`;
  }
});

// --- 커스텀 포맷: CSS Variables (Dark) ---
StyleDictionary.registerFormat({
  name: 'css/axis-variables-dark',
  format: async ({ dictionary }) => {
    const tokens = dictionary.allTokens
      .map(token => `  --axis-${token.path.join('-')}: ${token.value};`)
      .join('\n');

    return `.dark {\n${tokens}\n}\n`;
  }
});

// --- 커스텀 포맷: TypeScript 모듈 ---
StyleDictionary.registerFormat({
  name: 'typescript/axis-module',
  format: async ({ dictionary }) => {
    const tokens = {};

    dictionary.allTokens.forEach(token => {
      let current = tokens;
      token.path.forEach((key, index) => {
        if (index === token.path.length - 1) {
          current[key] = token.value;
        } else {
          current[key] = current[key] || {};
          current = current[key];
        }
      });
    });

    return `/**
 * AXIS Design System - Design Tokens
 * Generated by Style Dictionary
 * Do not edit directly
 */

export const tokens = ${JSON.stringify(tokens, null, 2)} as const;

export type Tokens = typeof tokens;

export default tokens;
`;
  }
});

// --- 커스텀 포맷: TypeScript 타입 정의 ---
StyleDictionary.registerFormat({
  name: 'typescript/axis-declarations',
  format: async () => {
    return `/**
 * AXIS Design System - Design Tokens Type Definitions
 * Generated by Style Dictionary
 * Do not edit directly
 */

declare const tokens: {
  color: Record<string, Record<string, string> | string>;
  space: Record<string, string>;
  radius: Record<string, string>;
  font: {
    family: Record<string, string>;
    size: Record<string, string>;
    weight: Record<string, string>;
    lineHeight: Record<string, string>;
  };
  surface: Record<string, string>;
  text: Record<string, string>;
  border: Record<string, string>;
  icon: Record<string, string>;
  button: Record<string, Record<string, string>>;
  input: Record<string, Record<string, string>>;
  card: Record<string, Record<string, string>>;
  badge: Record<string, Record<string, string>>;
  dialog: Record<string, Record<string, string>>;
};

export = tokens;
`;
  }
});

// --- 1. Light 토큰 빌드 ---
const sdLight = new StyleDictionary({
  source: [
    'src/primitives/**/*.json',
    'src/semantic/light.json',
    'src/component/**/*.json'
  ],
  platforms: {
    css: {
      transformGroup: 'css',
      buildPath: 'dist/css/',
      files: [{
        destination: '_light.css',
        format: 'css/axis-variables'
      }]
    },
    js: {
      transformGroup: 'js',
      buildPath: 'dist/js/',
      files: [
        {
          destination: 'tokens.mjs',
          format: 'typescript/axis-module'
        },
        {
          destination: 'tokens.js',
          format: 'javascript/module-flat'
        },
        {
          destination: 'tokens.d.ts',
          format: 'typescript/axis-declarations'
        }
      ]
    },
    json: {
      transformGroup: 'js',
      buildPath: 'dist/json/',
      files: [{
        destination: 'tokens.json',
        format: 'json/flat'
      }]
    }
  }
});

// --- 2. Dark 토큰 빌드 (semantic만 — component 토큰은 light 참조 기반이라 제외) ---
const sdDark = new StyleDictionary({
  source: [
    'src/primitives/**/*.json',
    'src/semantic/dark.json',
  ],
  platforms: {
    css: {
      transformGroup: 'css',
      buildPath: 'dist/css/',
      files: [{
        destination: '_dark.css',
        format: 'css/axis-variables-dark'
      }]
    }
  }
});

console.log('Building AXIS Design Tokens...');

// Light + JS/JSON 빌드
await sdLight.buildAllPlatforms();
console.log('  ✓ Light tokens built');

// Dark 빌드
await sdDark.buildAllPlatforms();
console.log('  ✓ Dark tokens built');

// --- 3. variables.css 결합 (light + dark) ---
import { readFileSync } from 'fs';

const lightCss = readFileSync('dist/css/_light.css', 'utf-8');
const darkCss = readFileSync('dist/css/_dark.css', 'utf-8');

const variablesCss = `/**
 * AXIS Design System - Design Tokens
 * Generated by Style Dictionary
 * Do not edit directly
 */

${lightCss}
${darkCss}`;

writeFileSync('dist/css/variables.css', variablesCss);
console.log('  ✓ variables.css (light + dark) merged');

// 임시 파일 삭제
import { unlinkSync } from 'fs';
try { unlinkSync('dist/css/_light.css'); } catch {}
try { unlinkSync('dist/css/_dark.css'); } catch {}

// --- 4. shadcn-compat.css 생성 ---
// JSON을 직접 파싱하여 토큰 참조를 resolve → HEX → HSL

function loadJson(filePath) {
  return JSON.parse(readFileSync(filePath, 'utf-8'));
}

function resolveRef(value, primitives) {
  if (typeof value !== 'string' || !value.startsWith('{')) return value;
  const path = value.replace(/[{}]/g, '').split('.');
  let current = primitives;
  for (const key of path) {
    current = current?.[key];
  }
  const resolved = current?.value ?? current;
  if (typeof resolved === 'string' && resolved.startsWith('{')) {
    return resolveRef(resolved, primitives);
  }
  return resolved;
}

const colorsJson = loadJson('src/primitives/colors.json');

function resolveSemanticJson(semanticPath) {
  const json = loadJson(semanticPath);
  const resolved = {};
  for (const [cat, entries] of Object.entries(json)) {
    resolved[cat] = {};
    for (const [key, token] of Object.entries(entries)) {
      resolved[cat][key] = resolveRef(token.value, colorsJson);
    }
  }
  return resolved;
}

const lightResolved = resolveSemanticJson('src/semantic/light.json');
const darkResolved = resolveSemanticJson('src/semantic/dark.json');

function toHslFromHex(hex) {
  if (!hex || !hex.startsWith('#')) return '0 0% 0%';
  return hexToHsl(hex);
}

function getColor(colorName, shade) {
  return colorsJson?.color?.[colorName]?.[shade]?.value || '#000000';
}

function buildShadcnVars(resolved) {
  return [
    `    --background: ${toHslFromHex(resolved.surface?.default)};`,
    `    --foreground: ${toHslFromHex(resolved.text?.primary)};`,
    `    --card: ${toHslFromHex(resolved.surface?.default)};`,
    `    --card-foreground: ${toHslFromHex(resolved.text?.primary)};`,
    `    --popover: ${toHslFromHex(resolved.surface?.default)};`,
    `    --popover-foreground: ${toHslFromHex(resolved.text?.primary)};`,
    `    --primary: ${toHslFromHex(resolved.text?.primary)};`,
    `    --primary-foreground: ${toHslFromHex(resolved.text?.inverse)};`,
    `    --secondary: ${toHslFromHex(resolved.surface?.secondary)};`,
    `    --secondary-foreground: ${toHslFromHex(resolved.text?.primary)};`,
    `    --muted: ${toHslFromHex(resolved.surface?.secondary)};`,
    `    --muted-foreground: ${toHslFromHex(resolved.text?.secondary)};`,
    `    --accent: ${toHslFromHex(resolved.surface?.secondary)};`,
    `    --accent-foreground: ${toHslFromHex(resolved.text?.primary)};`,
    `    --destructive: ${toHslFromHex(getColor('red', '500'))};`,
    `    --destructive-foreground: ${toHslFromHex(resolved.text?.inverse)};`,
    `    --border: ${toHslFromHex(resolved.border?.default)};`,
    `    --input: ${toHslFromHex(resolved.border?.default)};`,
    `    --ring: ${toHslFromHex(resolved.border?.focus)};`,
    `    --radius: 0.5rem;`,
    `    --chart-1: ${toHslFromHex(getColor('blue', '500'))};`,
    `    --chart-2: ${toHslFromHex(getColor('green', '500'))};`,
    `    --chart-3: ${toHslFromHex(getColor('yellow', '500'))};`,
    `    --chart-4: ${toHslFromHex(getColor('purple', '500'))};`,
    `    --chart-5: ${toHslFromHex(getColor('orange', '500'))};`,
  ].join('\n');
}

const shadcnCss = `/**
 * AXIS Design System - shadcn/ui Compatible CSS Variables
 * Generated from AXIS tokens — maps to shadcn variable names (HSL format)
 * Do not edit directly
 *
 * Usage:
 *   @import '@axis-ds/tokens/css/shadcn';
 */

:root {
${buildShadcnVars(lightResolved)}
}

.dark {
${buildShadcnVars(darkResolved)}
}

* {
  border-color: hsl(var(--border));
}

body {
  background-color: hsl(var(--background));
  color: hsl(var(--foreground));
}
`;

mkdirSync('dist/css', { recursive: true });
writeFileSync('dist/css/shadcn-compat.css', shadcnCss);
console.log('  ✓ shadcn-compat.css generated');

console.log('Done!');
